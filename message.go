package blades

import (
	"fmt"
	"strings"

	"github.com/google/uuid"
)

// Role indicates the author of a message in a conversation.
type Role string

const (
	// RoleUser is an end user.
	RoleUser Role = "user"
	// RoleSystem provides system-level instructions.
	RoleSystem Role = "system"
	// RoleAssistant is the model output.
	RoleAssistant Role = "assistant"
	// RoleTool indicates a message generated by a tool.
	RoleTool Role = "tool"
)

// Status indicates the state of a message.
type Status string

const (
	// StatusInProgress indicates the message is being generated.
	StatusInProgress Status = "in_progress"
	// StatusIncomplete indicates the message is partially generated.
	StatusIncomplete Status = "incomplete"
	// StatusCompleted indicates the message is fully generated.
	StatusCompleted Status = "completed"
)

// TextPart is plain text content.
type TextPart struct {
	Text string `json:"text"`
}

// FilePart is a reference to a file by its URI.
type FilePart struct {
	Name     string   `json:"name"`
	URI      string   `json:"uri"`
	MimeType MimeType `json:"mimeType"`
}

// DataPart is a file represented by its byte content.
type DataPart struct {
	Name     string   `json:"name"`
	Bytes    []byte   `json:"bytes"`
	MimeType MimeType `json:"mimeType"`
}

// Part is a part of a message, which can be text or a file.
type Part interface {
	isPart()
}

func (TextPart) isPart() {}
func (FilePart) isPart() {}
func (DataPart) isPart() {}

// ToolCall represents a call to an external tool.
type ToolCall struct {
	ID        string `json:"id"`
	Name      string `json:"name"`
	Arguments string `json:"arguments"`
	Result    string `json:"result,omitempty"`
}

// Message represents a single message in a conversation.
type Message struct {
	ID        string            `json:"id"`
	Role      Role              `json:"role"`
	Parts     []Part            `json:"parts"`
	Status    Status            `json:"status"`
	ToolCalls []*ToolCall       `json:"toolCalls,omitempty"`
	Metadata  map[string]string `json:"metadata,omitempty"`
}

// AsText returns the first text part of the message, or an empty string if none exists.
func (m *Message) AsText() string {
	for _, part := range m.Parts {
		if text, ok := part.(TextPart); ok {
			return text.Text
		}
	}
	return ""
}

func (m *Message) String() string {
	var buf strings.Builder
	for _, part := range m.Parts {
		switch v := part.(type) {
		case TextPart:
			buf.WriteString("[Text: " + v.Text + ")]")
		case FilePart:
			buf.WriteString("[File: " + v.Name + " (" + string(v.MimeType) + ")]")
		case DataPart:
			buf.WriteString("[Data: " + v.Name + " (" + string(v.MimeType) + "), " + fmt.Sprintf("%d bytes", len(v.Bytes)) + "]")
		}
	}
	return buf.String()
}

// contentPart is a type constraint for valid content inputs.
type contentPart interface {
	string | TextPart | FilePart | DataPart
}

// UserMessage creates a user-authored message from parts.
func UserMessage[T contentPart](parts ...T) *Message {
	return &Message{ID: NewMessageID(), Role: RoleUser, Parts: Parts(parts...)}
}

// SystemMessage creates a system-authored message from parts.
func SystemMessage[T contentPart](parts ...T) *Message {
	return &Message{ID: NewMessageID(), Role: RoleSystem, Parts: Parts(parts...)}
}

// AssistantMessage creates an assistant-authored message from parts.
func AssistantMessage[T contentPart](parts ...T) *Message {
	return &Message{ID: NewMessageID(), Role: RoleAssistant, Parts: Parts(parts...)}
}

// Parts converts a heterogeneous list of content inputs into model parts.
// Accepts raw string, Text, FileURI, and FileBytes.
func Parts[T contentPart](inputs ...T) []Part {
	parts := make([]Part, 0, len(inputs))
	for _, input := range inputs {
		switch v := any(input).(type) {
		case string:
			parts = append(parts, TextPart{v})
		case TextPart:
			parts = append(parts, v)
		case FilePart:
			parts = append(parts, v)
		case DataPart:
			parts = append(parts, v)
		}
	}
	return parts
}

// NewMessageID generates a new random message identifier.
func NewMessageID() string {
	return uuid.NewString()
}

// NewTextPart creates a new TextPart from a string.
func NewTextPart(text string) TextPart {
	return TextPart{Text: text}
}

// NewFilePart creates a new FilePart with the given name, URI, and mime type.
func NewFilePart(name, uri string, mimeType MimeType) FilePart {
	return FilePart{
		Name:     name,
		URI:      uri,
		MimeType: mimeType,
	}
}

// NewDataPart creates a new DataPart with the given name, bytes, and mime type.
func NewDataPart(name string, data []byte, mimeType MimeType) DataPart {
	return DataPart{
		Name:     name,
		Bytes:    data,
		MimeType: mimeType,
	}
}

// NewImagePart creates a new FilePart or DataPart for an image.
// uriOrBase64 can be either a URI or base64 encoded data (with or without data URL prefix).
// If mimeType is provided, it will be used; otherwise, it will be auto-detected.
func NewImagePart(name, uriOrBase64 string, mimeType ...MimeType) Part {
	var mime MimeType
	if len(mimeType) > 0 {
		// Use explicitly provided MIME type
		mime = mimeType[0]
	} else {
		// Auto-detect MIME type
		mime = MimeImagePNG // default
		if isBase64Data(uriOrBase64) {
			// For base64 data, try to extract MIME from data URL prefix
			if strings.HasPrefix(uriOrBase64, "data:") {
				mime = extractMimeFromDataURL(uriOrBase64)
			}
		} else {
			// For URI, detect from file extension
			uriPath := extractPathFromURI(uriOrBase64)
			if strings.HasSuffix(strings.ToLower(uriPath), ".jpg") || strings.HasSuffix(strings.ToLower(uriPath), ".jpeg") {
				mime = MimeImageJPEG
			}
		}
	}

	if isBase64Data(uriOrBase64) {
		// Return DataPart for base64 data
		data := extractBase64Data(uriOrBase64)
		return DataPart{
			Name:     name,
			Bytes:    data,
			MimeType: mime,
		}
	} else {
		// Return FilePart for URI
		return FilePart{
			Name:     name,
			URI:      uriOrBase64,
			MimeType: mime,
		}
	}
}

// NewAudioPart creates a new FilePart or DataPart for an audio file.
// uriOrBase64 can be either a URI or base64 encoded data (with or without data URL prefix).
// If mimeType is provided, it will be used; otherwise, it will be auto-detected.
func NewAudioPart(name, uriOrBase64 string, mimeType ...MimeType) Part {
	var mime MimeType
	if len(mimeType) > 0 {
		// Use explicitly provided MIME type
		mime = mimeType[0]
	} else {
		// Auto-detect MIME type
		mime = MimeAudioWAV // default
		if isBase64Data(uriOrBase64) {
			// For base64 data, try to extract MIME from data URL prefix
			if strings.HasPrefix(uriOrBase64, "data:") {
				mime = extractMimeFromDataURL(uriOrBase64)
			}
		} else {
			// For URI, detect from file extension
			uriPath := extractPathFromURI(uriOrBase64)
			lowerPath := strings.ToLower(uriPath)
			if strings.HasSuffix(lowerPath, ".mp3") {
				mime = MimeAudioMP3
			} else if strings.HasSuffix(lowerPath, ".ogg") {
				mime = MimeAudioOGG
			}
		}
	}

	if isBase64Data(uriOrBase64) {
		// Return DataPart for base64 data
		data := extractBase64Data(uriOrBase64)
		return DataPart{
			Name:     name,
			Bytes:    data,
			MimeType: mime,
		}
	} else {
		// Return FilePart for URI
		return FilePart{
			Name:     name,
			URI:      uriOrBase64,
			MimeType: mime,
		}
	}
}
