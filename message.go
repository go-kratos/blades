package blades

import (
	"fmt"
	"strings"

	"github.com/google/uuid"
)

// Role indicates the author of a message in a conversation.
type Role string

const (
	// RoleUser is an end user.
	RoleUser Role = "user"
	// RoleSystem provides system-level instructions.
	RoleSystem Role = "system"
	// RoleAssistant is the model output.
	RoleAssistant Role = "assistant"
	// RoleTool indicates a message generated by a tool.
	RoleTool Role = "tool"
)

// Status indicates the state of a message.
type Status string

const (
	// StatusInProgress indicates the message is being generated.
	StatusInProgress Status = "in_progress"
	// StatusIncomplete indicates the message is partially generated.
	StatusIncomplete Status = "incomplete"
	// StatusCompleted indicates the message is fully generated.
	StatusCompleted Status = "completed"
)

// TextPart is plain text content.
type TextPart struct {
	Text string `json:"text"`
}

// FilePart is a reference to a file by its URI.
type FilePart struct {
	Name     string   `json:"name"`
	URI      string   `json:"uri"`
	MIMEType MIMEType `json:"mimeType"`
}

// DataPart is a file represented by its byte content.
type DataPart struct {
	Name     string   `json:"name"`
	Bytes    []byte   `json:"bytes"`
	MIMEType MIMEType `json:"mimeType"`
}

// Part is a part of a message, which can be text or a file.
type Part interface {
	isPart()
}

func (TextPart) isPart() {}
func (FilePart) isPart() {}
func (DataPart) isPart() {}

// ToolCall represents a call to an external tool.
type ToolCall struct {
	ID        string `json:"id"`
	Name      string `json:"name"`
	Arguments string `json:"arguments"`
	Result    string `json:"result,omitempty"`
}

// Message represents a single message in a conversation.
type Message struct {
	ID        string            `json:"id"`
	Role      Role              `json:"role"`
	Parts     []Part            `json:"parts"`
	Status    Status            `json:"status"`
	ToolCalls []*ToolCall       `json:"toolCalls,omitempty"`
	Metadata  map[string]string `json:"metadata,omitempty"`
}

// Text returns the first text part of the message, or an empty string if none exists.
func (m *Message) Text() string {
	for _, part := range m.Parts {
		if text, ok := part.(TextPart); ok {
			return text.Text
		}
	}
	return ""
}

// File returns the first file part of the message, or nil if none exists.
func (m *Message) File() *FilePart {
	for _, part := range m.Parts {
		if file, ok := part.(FilePart); ok {
			return &file
		}
	}
	return nil
}

// Data returns the first data part of the message, or nil if none exists.
func (m *Message) Data() *DataPart {
	for _, part := range m.Parts {
		if data, ok := part.(DataPart); ok {
			return &data
		}
	}
	return nil
}

func (m *Message) String() string {
	var buf strings.Builder
	for _, part := range m.Parts {
		switch v := part.(type) {
		case TextPart:
			buf.WriteString("[Text: " + v.Text + ")]")
		case FilePart:
			buf.WriteString("[File: " + v.Name + " (" + string(v.MIMEType) + ")]")
		case DataPart:
			buf.WriteString("[Data: " + v.Name + " (" + string(v.MIMEType) + "), " + fmt.Sprintf("%d bytes", len(v.Bytes)) + "]")
		}
	}
	return buf.String()
}

// contentPart is a type constraint for valid content inputs.
type contentPart interface {
	string | TextPart | FilePart | DataPart
}

// UserMessage creates a user-authored message from parts.
func UserMessage[T contentPart](parts ...T) *Message {
	return &Message{ID: NewMessageID(), Role: RoleUser, Parts: Parts(parts...)}
}

// SystemMessage creates a system-authored message from parts.
func SystemMessage[T contentPart](parts ...T) *Message {
	return &Message{ID: NewMessageID(), Role: RoleSystem, Parts: Parts(parts...)}
}

// AssistantMessage creates an assistant-authored message from parts.
func AssistantMessage[T contentPart](parts ...T) *Message {
	return &Message{ID: NewMessageID(), Role: RoleAssistant, Parts: Parts(parts...)}
}

// Parts converts a heterogeneous list of content inputs into model parts.
// Accepts raw string, Text, FileURI, and FileBytes.
func Parts[T contentPart](inputs ...T) []Part {
	parts := make([]Part, 0, len(inputs))
	for _, input := range inputs {
		switch v := any(input).(type) {
		case string:
			parts = append(parts, TextPart{v})
		case TextPart:
			parts = append(parts, v)
		case FilePart:
			parts = append(parts, v)
		case DataPart:
			parts = append(parts, v)
		}
	}
	return parts
}

// NewMessageID generates a new random message identifier.
func NewMessageID() string {
	return uuid.NewString()
}
