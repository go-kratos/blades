package blades

import (
	"fmt"
	"strings"

	"github.com/google/uuid"
)

// Role indicates the author of a message in a conversation.
type Role string

const (
	// RoleUser is an end user.
	RoleUser Role = "user"
	// RoleSystem provides system-level instructions.
	RoleSystem Role = "system"
	// RoleAssistant is the model output.
	RoleAssistant Role = "assistant"
	// RoleTool indicates a message generated by a tool.
	RoleTool Role = "tool"
)

// Status indicates the state of a message.
type Status string

const (
	// StatusInProgress indicates the message is being generated.
	StatusInProgress Status = "in_progress"
	// StatusIncomplete indicates the message is partially generated.
	StatusIncomplete Status = "incomplete"
	// StatusCompleted indicates the message is fully generated.
	StatusCompleted Status = "completed"
)

// TextPart is plain text content.
type TextPart struct {
	Text string `json:"text"`
}

// FilePart is a reference to a file by its URI.
type FilePart struct {
	Name     string   `json:"name"`
	URI      string   `json:"uri"`
	MIMEType MIMEType `json:"mimeType"`
}

// DataPart is a file represented by its byte content.
type DataPart struct {
	Name     string   `json:"name"`
	Bytes    []byte   `json:"bytes"`
	MIMEType MIMEType `json:"mimeType"`
}

type ToolPart struct {
	ID       string `json:"id"`
	Name     string `json:"name"`
	Request  string `json:"arguments"`
	Response string `json:"result,omitempty"`
}

// Part is a part of a message, which can be text or a file.
type Part interface {
	isPart()
}

func (TextPart) isPart() {}
func (FilePart) isPart() {}
func (DataPart) isPart() {}
func (ToolPart) isPart() {}

// TokenUsage tracks token consumption for a message.
type TokenUsage struct {
	PromptTokens     int64 `json:"promptTokens"`
	CompletionTokens int64 `json:"completionTokens"`
	TotalTokens      int64 `json:"totalTokens"`
}

// Message represents a single message in a conversation.
type Message struct {
	ID           string            `json:"id"`
	Role         Role              `json:"role"`
	Parts        []Part            `json:"parts"`
	Status       Status            `json:"status"`
	Refusal      string            `json:"refusal,omitempty"`
	FinishReason string            `json:"finishReason,omitempty"`
	TokenUsage   TokenUsage        `json:"tokenUsage,omitempty"`
	Metadata     map[string]string `json:"metadata,omitempty"`
}

// Text returns the first text part of the message, or an empty string if none exists.
func (m *Message) Text() string {
	var buf strings.Builder
	for _, part := range m.Parts {
		switch v := any(part).(type) {
		case TextPart:
			buf.WriteString(v.Text)
			buf.WriteByte('\n')
		}
	}
	return strings.TrimSuffix(buf.String(), "\n")
}

// File returns the first file part of the message, or nil if none exists.
func (m *Message) File() *FilePart {
	for _, part := range m.Parts {
		if file, ok := part.(FilePart); ok {
			return &file
		}
	}
	return nil
}

// Data returns the first data part of the message, or nil if none exists.
func (m *Message) Data() *DataPart {
	for _, part := range m.Parts {
		if data, ok := part.(DataPart); ok {
			return &data
		}
	}
	return nil
}

func (m *Message) String() string {
	var buf strings.Builder
	for _, part := range m.Parts {
		switch v := part.(type) {
		case TextPart:
			buf.WriteString("[Text: " + v.Text + ")]")
		case FilePart:
			buf.WriteString("[File: " + v.Name + " (" + string(v.MIMEType) + ")]")
		case DataPart:
			buf.WriteString("[Data: " + v.Name + " (" + string(v.MIMEType) + "), " + fmt.Sprintf("%d bytes", len(v.Bytes)) + "]")
		case ToolPart:
			buf.WriteString("[Tool: " + v.Name + " (Request: " + v.Request + ", Response: " + v.Response + ")]")
		}
	}
	return buf.String()
}

// contentPart is a type constraint for valid content inputs.
type contentPart interface {
	string | TextPart | FilePart | DataPart | ToolPart
}

// UserMessage creates a user-authored message from parts.
func UserMessage[T contentPart](parts ...T) *Message {
	return &Message{ID: NewMessageID(), Role: RoleUser, Parts: Parts(parts...)}
}

// SystemMessage creates a system-authored message from parts.
func SystemMessage[T contentPart](parts ...T) *Message {
	return &Message{ID: NewMessageID(), Role: RoleSystem, Parts: Parts(parts...)}
}

// AssistantMessage creates an assistant-authored message from parts.
func AssistantMessage[T contentPart](parts ...T) *Message {
	return &Message{ID: NewMessageID(), Role: RoleAssistant, Parts: Parts(parts...)}
}

// Parts converts a heterogeneous list of content inputs into model parts.
// Accepts raw string, Text, FileURI, and FileBytes.
func Parts[T contentPart](inputs ...T) []Part {
	parts := make([]Part, 0, len(inputs))
	for _, input := range inputs {
		switch v := any(input).(type) {
		case string:
			parts = append(parts, TextPart{v})
		case TextPart:
			parts = append(parts, v)
		case FilePart:
			parts = append(parts, v)
		case DataPart:
			parts = append(parts, v)
		case ToolPart:
			parts = append(parts, v)
		}
	}
	return parts
}

// NewMessage creates a new empty message with a unique ID.
func NewMessage(role Role) *Message {
	return &Message{ID: NewMessageID(), Role: role}
}

// NewMessageID generates a new random message identifier.
func NewMessageID() string {
	return uuid.NewString()
}
